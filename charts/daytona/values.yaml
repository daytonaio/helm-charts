# Default values for daytona.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Global configuration
global:
  imageRegistry: ""
  imagePullSecrets: []
  storageClass: ""
  namespace: "" # If not set, will default to Release.Namespace

# Base domain Daytona
domain: "daytona.example.com"

# Service-specific configurations
services:
  api:
    enabled: true
    # Image configuration
    image:
      registry: docker.io
      repository: daytonaio/daytona-api
      tag: "" # Will default to Chart.AppVersion
      pullPolicy: IfNotPresent
    # Service configuration
    service:
      type: ClusterIP
      port: 3000
      annotations: {}
    # Ingress configuration
    ingress:
      enabled: true
      className: "nginx"
      annotations:
        nginx.ingress.kubernetes.io/ssl-redirect: "true"
      hosts:
        - host: "daytona.example.com"
          paths:
            - path: /
              pathType: Prefix
      tls:
        - hosts:
            - "daytona.example.com"
          secretName: "daytona.example.com-tls"
    # Environment variables (can be overridden via Helm values)
    env:
      # Application configuration
      ENVIRONMENT: "production"
      PORT: "3000"

      # OIDC configuration
      OIDC_CLIENT_ID: "daytona"
      OIDC_ISSUER_BASE_URL: "https://daytona.example.com/idp/realms/daytona"
      PUBLIC_OIDC_DOMAIN: "https://daytona.example.com/idp/realms/daytona"
      OIDC_AUDIENCE: "daytona"
      OIDC_MANAGEMENT_API_ENABLED: "false"
      OIDC_MANAGEMENT_API_CLIENT_ID: ""
      OIDC_MANAGEMENT_API_CLIENT_SECRET: ""
      OIDC_MANAGEMENT_API_AUDIENCE: ""

      # Workspace configuration
      DEFAULT_SNAPSHOT: "daytonaio/sandbox:0.5.0"
      DASHBOARD_URL: "https://daytona.example.com/dashboard"
      DASHBOARD_BASE_API_URL: "https://daytona.example.com"

      # OTEL configuration
      OTEL_ENABLED: "true"
      OTEL_COLLECTOR_URL: "http://daytona-jaeger:4318/v1/traces"

      # Registry configuration (Harbor)
      # If Harbor is enabled, will use Harbor ingress URL and credentials
      TRANSIENT_REGISTRY_URL: ""
      TRANSIENT_REGISTRY_ADMIN: ""
      TRANSIENT_REGISTRY_PASSWORD: ""
      TRANSIENT_REGISTRY_PROJECT_ID: ""
      INTERNAL_REGISTRY_URL: ""
      INTERNAL_REGISTRY_ADMIN: ""
      INTERNAL_REGISTRY_PASSWORD: ""
      INTERNAL_REGISTRY_PROJECT_ID: ""

      # SMTP configuration
      SMTP_HOST: ""
      SMTP_PORT: ""
      SMTP_USER: ""
      SMTP_PASSWORD: ""
      SMTP_SECURE: ""
      SMTP_EMAIL_FROM: ""

      # S3 configuration
      S3_ENDPOINT: "http://daytona-minio:9000"
      S3_STS_ENDPOINT: "http://daytona-minio:9000/minio/v1/assume-role"
      S3_REGION: "us-east-1"
      S3_ACCESS_KEY: "minioadmin"
      S3_SECRET_KEY: "minioadmin"

      # Runner configuration
      DEFAULT_RUNNER_DOMAIN: ""
      DEFAULT_RUNNER_API_URL: ""
      DEFAULT_RUNNER_PROXY_URL: ""
      DEFAULT_RUNNER_API_KEY: ""
      DEFAULT_RUNNER_CPU: "4"
      DEFAULT_RUNNER_MEMORY: "8"
      DEFAULT_RUNNER_DISK: "50"
      DEFAULT_RUNNER_GPU: "0"
      DEFAULT_RUNNER_GPU_TYPE: "none"
      DEFAULT_RUNNER_CAPACITY: "100"
      DEFAULT_RUNNER_REGION: "us"
      DEFAULT_RUNNER_CLASS: "small"

    # Resource limits and requests
    resources:
      limits:
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 128Mi
    # Node selector
    nodeSelector: {}
    # Tolerations
    tolerations: []
    # Affinity
    affinity: {}
    # Annotations
    annotations: {}
    # Pod annotations
    podAnnotations: {}
    # Replica count
    replicaCount: 1
    # Service account
    serviceAccount:
      create: true
      annotations: {}
      name: ""

  proxy:
    enabled: true
    # Image configuration
    image:
      registry: docker.io
      repository: daytonaio/daytona-proxy
      tag: "" # Will default to Chart.AppVersion
      pullPolicy: IfNotPresent
    # Service configuration
    service:
      type: ClusterIP
      port: 4000
      annotations: {}
    # Ingress configuration
    ingress:
      enabled: true
      className: "nginx"
      annotations:
        nginx.ingress.kubernetes.io/ssl-redirect: "true"
        nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
        nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
      hosts:
        - host: "proxy.daytona.example.com"
          paths:
            - path: /
              pathType: Prefix
        - host: "*.proxy.daytona.example.com"
          paths:
            - path: /
              pathType: Prefix
      tls:
        - hosts:
            - "proxy.daytona.example.com"
            - "*.proxy.daytona.example.com"
          secretName: "daytona.example.com-tls"
    # Environment variables
    env:
      OIDC_CLIENT_ID: "daytona"
      OIDC_CLIENT_SECRET: ""
      OIDC_DOMAIN: "https://daytona.example.com/idp/realms/daytona"
      OIDC_AUDIENCE: "daytona"
      PROXY_PORT: 80
      PROXY_DOMAIN: proxy.daytona.example.com:80
      PROXY_API_KEY: "super_secret_key"
      PROXY_PROTOCOL: http
    # Resource limits and requests
    resources:
      limits:
        memory: 256Mi
      requests:
        cpu: 100m
        memory: 64Mi
    # Node selector
    nodeSelector: {}
    # Tolerations
    tolerations: []
    # Affinity
    affinity: {}
    # Annotations
    annotations: {}
    # Pod annotations
    podAnnotations: {}
    # Replica count
    replicaCount: 1
    # Service account
    serviceAccount:
      create: true
      annotations: {}
      name: ""

  sshGateway:
    enabled: true
    # Image configuration
    image:
      registry: docker.io
      repository: daytonaio/daytona-ssh-gateway
      tag: "" # Will default to Chart.AppVersion
      pullPolicy: IfNotPresent
    # Service configuration
    service:
      type: LoadBalancer
      port: 2222
      annotations: {}
    # Set api key for ssh gateway. This key is used to authenticate the ssh gateway against api
    apiKey: supersecretapikey
    # Generate ssh keys to be used for the ssh gateway. These keys are stored in the secret and used to authenticate the ssh gateway. Generate keys using ssh-keygen and store them as base64 values here
    sshKeys:
      privClientSSHKey: ""
      pubClientSSHKey: ""
      privGatewaySSHKey: ""
    env:
      SSH_GATEWAY_PORT: "2222"
      SSH_GATEWAY_HOST: "ssh.daytona.example.com"
    # Resource limits and requests
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
      requests:
        cpu: 10m
        memory: 64Mi
    # Node selector
    nodeSelector: {}
    # Tolerations
    tolerations: []
    # Affinity
    affinity: {}
    # Annotations
    annotations: {}
    # Pod annotations
    podAnnotations: {}
    # Replica count
    replicaCount: 1
    # Service account
    serviceAccount:
      create: true
      annotations: {}
      name: ""

  jaeger:
    enabled: true
    image:
      registry: docker.io
      repository: jaegertracing/all-in-one
      tag: 1.67.0
      pullPolicy: IfNotPresent
    # Service configuration
    service:
      type: ClusterIP
      port: 4318
    # Resource limits and requests
    resources:
      limits:
        memory: 256Mi
      requests:
        cpu: 10m
        memory: 64Mi
    # Node selector
    nodeSelector: {}
    # Tolerations
    tolerations: []
    # Affinity
    affinity: {}
    # Annotations
    annotations: {}
    # Pod annotations
    podAnnotations: {}
    # Replica count
    replicaCount: 1

# Global node selector (fallback)
nodeSelector: {}

# Global tolerations (fallback)
tolerations: []

# Global affinity (fallback)
affinity: {}

# Pod security context
podSecurityContext:
  fsGroup: 2000

# Container security context
securityContext:
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false
  runAsNonRoot: false
  runAsUser: 0

## Daytona External Database Configuration
## All of these values are only used if `postgresql.enabled=false`
externalDatabase:
  host: "daytona-postgresql"
  port: 5432
  name: "daytona"
  user: "user"
  # Enable TLS/SSL for database connection
  enableTLS: true
  # Allow self-signed or internal certificates
  allowSelfSignedCert: true
  # Ignored if existingSecret is provided
  password: "pass"
  # If existingSecret is provided, it should contain key: database-password
  existingSecret: ""

# External Redis Configuration
# All of these values are only used if `redis.enabled=false`
externalRedis:
  host: "daytona-redis-master"
  port: 6379
  tls: false
  # Ignored if existingSecret is provided
  password: ""
  # If existingSecret is provided, it should contain key: redis-password
  existingSecret: ""

# Redis configuration
redis:
  enabled: true
  global:
    security:
      allowInsecureImages: true
  image:
    registry: docker.io
    repository: bitnamilegacy/redis
  auth:
    enabled: false
  persistence:
    enabled: true
    size: 1Gi
  containerPorts:
    redis: 6379
  replica:
    replicaCount: 0

# PgAdmin subchart configuration
pgadmin4:
  enabled: true
  env:
    email: "dev@daytona.io"
    password: "SuperSecrets"
  service:
    type: ClusterIP
    port: 80
  persistentVolume:
    enabled: true
    size: 1Gi
  serverDefinitions:
    enabled: true
    resourceType: ConfigMap
    servers:
      daytona:
        Name: "Daytona"
        Group: "Servers"
        Host: "daytona-postgresql"
        Port: 5432
        MaintenanceDB: "postgres"
        Username: "user"
        Password: "pass"

# Harbor subchart configuration
harbor:
  enabled: true
  # Harbor configuration
  expose:
    type: ingress
    tls:
      enabled: true
      certSource: secret
      secret:
        secretName: "daytona.example.com-tls"
    ingress:
      className: nginx
      annotations:
        nginx.ingress.kubernetes.io/ssl-redirect: "true"
        nginx.ingress.kubernetes.io/proxy-body-size: "0"
      hosts:
        core: "harbor.daytona.example.com"
  existingSecretAdminPassword: ""
  existingSecretAdminPasswordKey: HARBOR_ADMIN_PASSWORD
  harborAdminPassword: "Harbor12345"
  externalURL: "https://harbor.daytona.example.com"
  # The persistence is enabled by default and a default StorageClass
# is needed in the k8s cluster to provision volumes dynamically.
# Specify another StorageClass in the "storageClass" or set "existingClaim"
# if you already have existing persistent volumes to use
#
# For storing images and charts, you can also use "azure", "gcs", "s3",
# "swift" or "oss". Set it in the "imageChartStorage" section
persistence:
  enabled: true
  # Setting it to "keep" to avoid removing PVCs during a helm delete
  # operation. Leaving it empty will delete PVCs after the chart deleted
  # (this does not apply for PVCs that are created for internal database
  # and redis components, i.e. they are never deleted automatically)
  resourcePolicy: "keep"
  persistentVolumeClaim:
    registry:
      # Use the existing PVC which must be created manually before bound,
      # and specify the "subPath" if the PVC is shared with other components
      existingClaim: ""
      # Specify the "storageClass" used to provision the volume. Or the default
      # StorageClass will be used (the default).
      # Set it to "-" to disable dynamic provisioning
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 5Gi
      annotations: {}
    jobservice:
      jobLog:
        existingClaim: ""
        storageClass: ""
        subPath: ""
        accessMode: ReadWriteOnce
        size: 1Gi
        annotations: {}
    # If external database is used, the following settings for database will
    # be ignored
    database:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 1Gi
      annotations: {}
    # If external Redis is used, the following settings for Redis will
    # be ignored
    redis:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 1Gi
      annotations: {}
    trivy:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 5Gi
      annotations: {}
  # Define which storage backend is used for registry to store
  # images and charts. Refer to
  # https://github.com/distribution/distribution/blob/release/2.8/docs/configuration.md#storage
  # for the detail.
  imageChartStorage:
    # Specify whether to disable `redirect` for images and chart storage, for
    # backends which not supported it (such as using minio for `s3` storage type), please disable
    # it. To disable redirects, simply set `disableredirect` to `true` instead.
    # Refer to
    # https://github.com/distribution/distribution/blob/release/2.8/docs/configuration.md#redirect
    # for the detail.
    disableredirect: false
    # Specify the "caBundleSecretName" if the storage service uses a self-signed certificate.
    # The secret must contain keys named "ca.crt" which will be injected into the trust store
    # of registry's containers.
    # caBundleSecretName:

    # Specify the type of storage: "filesystem", "azure", "gcs", "s3", "swift",
    # "oss" and fill the information needed in the corresponding section. The type
    # must be "filesystem" if you want to use persistent volumes for registry
    type: filesystem
    filesystem:
      rootdirectory: /storage
      #maxthreads: 100
    azure:
      accountname: accountname
      accountkey: base64encodedaccountkey
      container: containername
      #realm: core.windows.net
      # To use existing secret, the key must be AZURE_STORAGE_ACCESS_KEY
      existingSecret: ""
    gcs:
      bucket: bucketname
      # The base64 encoded json file which contains the key
      encodedkey: base64-encoded-json-key-file
      #rootdirectory: /gcs/object/name/prefix
      #chunksize: "5242880"
      # To use existing secret, the key must be GCS_KEY_DATA
      existingSecret: ""
      useWorkloadIdentity: false
    s3:
      # Set an existing secret for S3 accesskey and secretkey
      # keys in the secret should be REGISTRY_STORAGE_S3_ACCESSKEY and REGISTRY_STORAGE_S3_SECRETKEY for registry
      #existingSecret: ""
      region: us-west-1
      bucket: bucketname
      #accesskey: awsaccesskey
      #secretkey: awssecretkey
      #regionendpoint: http://myobjects.local
      #encrypt: false
      #keyid: mykeyid
      #secure: true
      #skipverify: false
      #v4auth: true
      #chunksize: "5242880"
      #rootdirectory: /s3/object/name/prefix
      #storageclass: STANDARD
      #multipartcopychunksize: "33554432"
      #multipartcopymaxconcurrency: 100
      #multipartcopythresholdsize: "33554432"
  trivy:
    enabled: false
  database:
    type: internal
  redis:
    type: internal
  persistence:
    enabled: true
    resourcePolicy: "keep"
    persistentVolumeClaim:
      registry:
        size: 10Gi
      jobservice:
        size: 1Gi

# MinIO subchart configuration
minio:
  enabled: true
  mode: standalone
  rootUser: "minioadmin"
  rootPassword: "minioadmin"
  replicas: 1
  resources:
    requests:
      memory: 2Gi
  buckets:
    - name: daytona
      policy: none
      purge: false
      versioning: false
      objectlocking: false
  persistence:
    enabled: true
    size: 8Gi
  service:
    type: ClusterIP
    port: 9000
  consoleService:
    type: ClusterIP
    port: 9001

# Keycloak subchart configuration
keycloak:
  enabled: true
  #nameOverride: "watkins-keycloak"
  global:
    security:
      allowInsecureImages: true
  image:
    registry: docker.io
    repository: bitnamilegacy/keycloak
    tag: 26.3.3-debian-12-r0
  keycloakConfigCli:
    enabled: true
    existingConfigmap: daytona-keycloak-realm-config
    image:
      registry: docker.io
      repository: bitnamilegacy/keycloak-config-cli
      tag: 6.4.0-debian-12-r11
  production: true
  proxyHeaders: "xforwarded"
  httpRelativePath: /idp/

  service:
    type: ClusterIP

  ingress:
    enabled: true
    ingressClassName: nginx
    annotations:
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
    hostname: "daytona.example.com"
    tls: true
    extraTls:
      - hosts:
          - "daytona.example.com"
        secretName: "daytona.example.com-tls"

  auth:
    adminUser: admin
    adminPassword: "admin"

  postgresql:
    enabled: true
    global:
      security:
        allowInsecureImages: true
    image:
      registry: docker.io
      repository: bitnamilegacy/postgresql
      tag: 17.6.0-debian-12-r0
    nameOverride: "keycloak-postgresql"

# PostgreSQL subchart
postgresql:
  enabled: true
  global:
    security:
      allowInsecureImages: true
  image:
    registry: docker.io
    repository: bitnamilegacy/postgresql
    tag: 17.6.0-debian-12-r0
  auth:
    postgresPassword: "pass"
    username: "user"
    password: "pass"
    database: "daytona"
  primary:
    persistence:
      enabled: true
      size: 8Gi
