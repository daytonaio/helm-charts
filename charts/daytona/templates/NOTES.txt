üéâ Daytona AI Infrastructure has been deployed successfully!

üìã ACCESS GUIDE:

1. üöÄ Daytona Services:
{{- $apiIngressEnabled := and .Values.services.api.ingress.enabled .Values.services.api.ingress.tls }}
{{- $apiHostname := .Values.services.api.ingress.hostname | default .Values.baseDomain }}
{{- $templatedApiHostname := tpl $apiHostname $ }}
{{- $dexIngressEnabled := and .Values.dex.enabled .Values.dex.ingress.enabled .Values.dex.ingress.tls }}
{{- $dexHostname := .Values.dex.ingress.hostname | default (printf "dex.%s" .Values.baseDomain) }}
{{- $templatedDexHostname := tpl $dexHostname $ }}
{{- if $apiIngressEnabled }}
   # Access via Ingress (TLS enabled):
   # Dashboard: https://{{ $templatedApiHostname }}/dashboard
   # API: https://{{ $templatedApiHostname }}/api
{{- if .Values.dex.enabled }}
   # Dex OIDC: https://{{ $templatedDexHostname }}/dex
   # Dashboard Login Credentials:
   # Username: {{ (index .Values.dex.config.staticPasswords 0).username | default "admin" }}
   # Password: password (or whatever is set via hash)
{{- end }}
{{- else }}
   # For local development, set up port-forwards:
   # Port-forward API service to localhost:8080
   kubectl port-forward -n {{ include "daytona.namespace" . }} svc/{{ include "daytona.fullname" . }}-api 8080:{{ .Values.services.api.service.port | default 3000 }}
{{- if .Values.dex.enabled }}
   # Port-forward Dex service to localhost:5556
   kubectl port-forward -n {{ include "daytona.namespace" . }} svc/{{ include "daytona.fullname" . }}-dex 5556:{{ .Values.dex.service.port | default 5556 }}
{{- end }}
   # Then access:
   # Dashboard: http://localhost:8080/dashboard
   # API: http://localhost:8080/api
{{- if .Values.dex.enabled }}
   # Dex OIDC: http://localhost:5556/dex
   # Dashboard Login Credentials:
   # Username: {{ (index .Values.dex.config.staticPasswords 0).username | default "admin" }}
   # Password: password (or whatever is set via hash)
{{- end }}
{{ end }}

2. üê≥ Harbor Portal (Container Registry):
   # Web UI: {{ .Values.harbor.externalURL }}
   # Username: admin
   # Password: {{ .Values.harbor.harborAdminPassword }}

{{- $sectionNum := 2 }}
{{- if .Values.minio.enabled }}
{{- $sectionNum = add $sectionNum 1 }}
{{ $sectionNum }}. üì¶ MinIO Console (Object Storage):
   kubectl port-forward -n {{ include "daytona.namespace" . }} svc/{{ include "daytona.fullname" . }}-minio-console 9001:{{ .Values.minio.consoleService.port }}
   # Then access: http://localhost:9001
   # Username: {{ .Values.minio.rootUser }}
   # Password: {{ .Values.minio.rootPassword }}
{{ end }}
{{- if .Values.pgadmin4.enabled }}
{{- $sectionNum = add $sectionNum 1 }}
{{ $sectionNum }}. üóÑÔ∏è PgAdmin (Database Management):
   kubectl port-forward -n {{ include "daytona.namespace" . }} svc/{{ include "daytona.fullname" . }}-pgadmin4 8083:80
   # Then access: http://localhost:8083
   # Username: {{ .Values.pgadmin4.env.email }}
   # Password: {{ .Values.pgadmin4.env.password }}
{{ end }}
üí° TIP: Run 'kubectl get pods -n {{ include "daytona.namespace" . }}' to check if all services are running!

üîë GENERATE ADMIN API KEY:

   # Get the API key (extracts only the key value)
   kubectl exec -n {{ include "daytona.namespace" . }} $(kubectl get pods -n {{ include "daytona.namespace" . }} -l "app.kubernetes.io/name={{ include "daytona.fullname" . }},app.kubernetes.io/component=api" -o jsonpath='{.items[0].metadata.name}') -- node dist/apps/api/main.js --create-admin-api-key "admin-$(date +%s)" 2>&1 | grep -oE "dtn_[a-zA-Z0-9]{64,}" | head -1

üèÉ DEPLOY DAYTONA RUNNER:

   After generating the admin API key above, deploy a Daytona runner on a clean Linux host:

   # Download and run the runner installation script
   curl -sSL https://download.daytona.io/install.sh | sudo bash

   # The script will prompt for:
{{- if $apiIngressEnabled }}
   # - Daytona API URL: https://{{ $templatedApiHostname }}/api
{{- else }}
   # - Daytona API URL: http://localhost:8080/api (or your API endpoint)
{{- end }}
   # - Admin API Key: (use the key generated above)

   This will install the Daytona runner binary and connect it to your Daytona API.
