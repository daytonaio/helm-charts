{{- if .Values.services.runner.enabled }}
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: {{ include "daytona.fullname" . }}-runner
  namespace: {{ include "daytona.namespace" . }}
  labels:
    {{- include "daytona.labels" . | nindent 4 }}
    app.kubernetes.io/component: runner
  {{- with .Values.services.runner.podAnnotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  selector:
    matchLabels:
      {{- include "daytona.selectorLabels" . | nindent 6 }}
      app.kubernetes.io/component: runner
      daytona.io/runner: "true"
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      {{- with .Values.services.runner.podAnnotations }}
      annotations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      labels:
        {{- include "daytona.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: runner
        daytona.io/runner: "true"
    spec:
      {{- with .Values.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      nodeSelector:
        daytona-sandbox-c: "true"
      tolerations:
        - key: "sandbox"
          operator: "Equal"
          value: "true"
          effect: "NoSchedule"
      hostNetwork: true
      hostPID: true
      dnsPolicy: ClusterFirstWithHostNet
      serviceAccountName: {{ include "daytona.serviceAccountName" (dict "Values" .Values "service" "runner" "Chart" .Chart "Release" .Release) }}
      terminationGracePeriodSeconds: 30
      {{- if .Values.services.runner.hostAliases }}
      hostAliases:
        {{- toYaml .Values.services.runner.hostAliases | nindent 8 }}
      {{- end }}
      {{- if and .Values.services.runner.dockerInstaller.enabled .Values.services.runner.dockerInstaller.airgapped.enabled }}
      initContainers:
        - name: extract-packages
          image: {{ .Values.services.runner.dockerInstaller.airgapped.packagesImage }}
          securityContext:
            privileged: true
          volumeMounts:
            - name: host-root
              mountPath: /host
              mountPropagation: Bidirectional
          command: ["/bin/sh", "-c"]
          args:
            - |
              echo "Extracting packages from image to host filesystem..."
              if [ ! -f /packages/packages.tar.gz ]; then
                echo "ERROR: /packages/packages.tar.gz not found in image"
                exit 1
              fi
              echo "Copying packages.tar.gz to host..."
              cp /packages/packages.tar.gz /host/tmp/packages.tar.gz
              echo "Extracting packages to host filesystem..."
              cd /host/tmp
              tar -xzf packages.tar.gz
              echo "Packages extracted successfully"
              ls -la /host/tmp/offline-packages/
      {{- end }}
      containers:
        {{- if .Values.services.runner.registryProxy.enabled }}
        # Socat sidecar to forward registry -> external registry
        - name: registry-proxy
          image: {{ .Values.services.runner.registryProxy.image }}
          args:
            - "TCP-LISTEN:{{ .Values.services.runner.registryProxy.listenPort }},fork,reuseaddr"
            - "TCP:{{ .Values.services.runner.registryProxy.targetHost }}:{{ .Values.services.runner.registryProxy.targetPort }}"
          securityContext:
            privileged: false
        {{- end }}
        {{- if .Values.services.runner.dockerInstaller.enabled }}
        # Docker installer sidecar - installs Docker on the host node
        - name: docker-installer
          image: {{ .Values.services.runner.dockerInstaller.image }}
          securityContext:
            privileged: true
          env:
            - name: XFS_STORAGE_SIZE
              value: {{ .Values.services.runner.dockerInstaller.xfsStorageSize | quote }}
            - name: AIRGAPPED_MODE
              value: {{ .Values.services.runner.dockerInstaller.airgapped.enabled | quote }}
          volumeMounts:
            - name: host-root
              mountPath: /host
              mountPropagation: Bidirectional
          command: ["/bin/sh", "-c"]
          args:
            - |
              echo "Starting Docker and Sysbox installation on host node..."
              echo "XFS Storage Size: ${XFS_STORAGE_SIZE}"
              echo "Airgapped Mode: ${AIRGAPPED_MODE}"
              
              {{- if .Values.services.runner.dockerInstaller.airgapped.enabled }}
              # Airgapped mode: Packages are already extracted by init container
              echo "Verifying packages are available..."
              if [ ! -d "/host/tmp/offline-packages" ]; then
                echo "ERROR: Packages directory not found at /host/tmp/offline-packages"
                exit 1
              fi
              ls -la /host/tmp/offline-packages/
              {{- end }}
              
              # First, add registry host entry to host's /etc/hosts for Docker to resolve
              echo "Adding registry host entry..."
              nsenter -t 1 -m -u -n -i sh -c '
                {{- range .Values.services.runner.hostAliases }}
                if ! grep -q "{{ .ip }}.*{{ index .hostnames 0 }}" /etc/hosts; then
                  echo "{{ .ip }} {{ range .hostnames }}{{ . }} {{ end }}" >> /etc/hosts
                  echo "Added host entry: {{ .ip }} {{ range .hostnames }}{{ . }} {{ end }}"
                else
                  echo "Host entry already exists for {{ index .hostnames 0 }}"
                fi
                {{- end }}
                cat /etc/hosts | grep -E "registry|minio" || true
              '
              
              # Enter the host namespace and install Docker + Sysbox
              nsenter -t 1 -m -u -n -i sh <<'EOF'
              
              # Set XFS storage size in host namespace (value injected at pod creation)
              export XFS_STORAGE_SIZE="{{ .Values.services.runner.dockerInstaller.xfsStorageSize }}"
              export AIRGAPPED_MODE="{{ .Values.services.runner.dockerInstaller.airgapped.enabled }}"
              
              # Offline packages location (used in airgapped mode)
              PACKAGES_DIR="/tmp/offline-packages"
              
              {{- if .Values.services.runner.dockerInstaller.airgapped.enabled }}
              # Function to install all dependencies from offline packages
              install_dependencies() {
                echo "Installing dependencies from offline packages..."
                
                if [ ! -d "$PACKAGES_DIR/dependencies" ]; then
                  echo "ERROR: Dependencies directory not found at $PACKAGES_DIR/dependencies"
                  return 1
                fi
                
                echo "Installing all dependency .deb packages (first pass)..."
                cd $PACKAGES_DIR/dependencies
                sudo dpkg -i --skip-same-version --refuse-downgrade *.deb 2>/dev/null || true
                
                echo "Installing all dependency .deb packages (second pass)..."
                sudo dpkg -i --skip-same-version --refuse-downgrade *.deb 2>/dev/null || true
                
                # Run dpkg configure to fix any remaining issues
                dpkg --configure -a
                
                echo "Dependencies installation completed"
                return 0
              }
              
              # Function to install Docker from offline packages
              install_docker() {
                if command -v docker >/dev/null 2>&1; then
                  echo "Docker is already installed"
                  docker version
                  return 0
                fi
                
                echo "Installing Docker from offline packages..."
                
                if [ ! -d "$PACKAGES_DIR/docker" ]; then
                  echo "ERROR: Docker packages directory not found at $PACKAGES_DIR/docker"
                  return 1
                fi
                
                # Install Docker CLI first, then Docker CE
                echo "Installing Docker CE CLI..."
                dpkg --force-depends -i $PACKAGES_DIR/docker/docker-ce-cli_*.deb
                
                echo "Installing Docker CE..."
                dpkg --force-depends -i $PACKAGES_DIR/docker/docker-ce_*.deb
                
                mkdir -p /etc/docker
                systemctl daemon-reload
                systemctl enable docker
                
                echo "Docker installation completed"
                return 0
              }
              
              # Function to install Sysbox from offline packages
              install_sysbox() {
                if command -v sysbox >/dev/null 2>&1 || [ -f /usr/bin/sysbox-runc ]; then
                  echo "Sysbox is already installed"
                  return 0
                fi
                
                echo "Installing Sysbox from offline packages..."
                
                if [ ! -d "$PACKAGES_DIR/sysbox" ]; then
                  echo "ERROR: Sysbox packages directory not found at $PACKAGES_DIR/sysbox"
                  return 1
                fi
                
                # Determine architecture
                ARCH=$(uname -m)
                if [ "$ARCH" != "x86_64" ] && [ "$ARCH" != "amd64" ]; then
                  echo "Sysbox only supports x86_64 architecture"
                  return 1
                fi
                
                # Stop Docker before installing Sysbox
                echo "Stopping Docker for Sysbox installation..."
                systemctl stop docker 2>/dev/null || true
                
                # Install Sysbox package
                echo "Installing Sysbox package..."
                dpkg -i $PACKAGES_DIR/sysbox/sysbox-ce_*.deb || {
                  echo "Sysbox install had issues, running dpkg configure..."
                  dpkg --configure -a
                }
                
                echo "Sysbox installation completed"
                return 0
              }
              {{- else }}
              # Function to install Docker and XFS tools (online mode)
              install_docker() {
                if command -v docker >/dev/null 2>&1; then
                  echo "Docker is already installed"
                  docker version
                  
                  # Still check/install XFS tools even if Docker exists
                  if ! command -v xfs_quota >/dev/null 2>&1; then
                    echo "Installing XFS tools..."
                    if command -v apt-get >/dev/null 2>&1; then
                      apt-get update
                      apt-get install -y xfsprogs
                    elif command -v yum >/dev/null 2>&1; then
                      yum install -y xfsprogs
                    fi
                  fi
                  return 0
                fi
                
                echo "Installing Docker and XFS tools..."
                
                if command -v apt-get >/dev/null 2>&1; then
                  # Debian/Ubuntu based - download Docker CE packages directly
                  cd /tmp
                  
                  # For Ubuntu 24.04 (noble)
                  DOCKER_VERSION="27.4.1-1~ubuntu.24.04~noble"

                  apt-get update
                  apt-get install -y wget xfsprogs
                  
                  wget https://download.docker.com/linux/ubuntu/dists/noble/pool/stable/amd64/docker-ce_${DOCKER_VERSION}_amd64.deb
                  wget https://download.docker.com/linux/ubuntu/dists/noble/pool/stable/amd64/docker-ce-cli_${DOCKER_VERSION}_amd64.deb
                  #wget https://download.docker.com/linux/ubuntu/dists/noble/pool/stable/amd64/docker-buildx-plugin_0.19.3-1~ubuntu.24.04~noble_amd64.deb
                  # Install with --force-depends to skip the containerd.io dependency
                  dpkg --force-depends -i docker-ce-cli_${DOCKER_VERSION}_amd64.deb
                  dpkg --force-depends -i docker-ce_${DOCKER_VERSION}_amd64.deb
                  
                  mkdir -p /etc/docker
                  systemctl daemon-reload
                  systemctl enable docker
                elif command -v yum >/dev/null 2>&1; then
                  # RHEL/CentOS based
                  yum install -y docker curl xfsprogs
                  systemctl enable docker
                fi
                
                echo "Docker and XFS tools installation completed"
                return 0
              }
              
              # Function to install Sysbox (online mode)
              install_sysbox() {
                if command -v sysbox >/dev/null 2>&1 || [ -f /usr/bin/sysbox-runc ]; then
                  echo "Sysbox is already installed"
                  return 0
                fi
                
                echo "Installing Sysbox from GitHub releases..."
                
                if command -v apt-get >/dev/null 2>&1; then
                  # Debian/Ubuntu based - install from GitHub
                  . /etc/os-release
                  
                  # Determine architecture
                  ARCH=$(uname -m)
                  if [ "$ARCH" != "x86_64" ] && [ "$ARCH" != "amd64" ]; then
                    echo "Sysbox only supports x86_64 architecture"
                    return 1
                  fi
                  
                  # Download latest Sysbox release
                  SYSBOX_VERSION="v0.6.4"
                  echo "Downloading Sysbox ${SYSBOX_VERSION}..."
                  
                  cd /tmp
                  
                  # Download the deb package
                  if curl -fsSLO "https://github.com/nestybox/sysbox/releases/download/${SYSBOX_VERSION}/sysbox-ce_0.6.4-0.linux_amd64.deb"; then
                    echo "Downloaded Sysbox package successfully"
                  else
                    echo "Failed to download Sysbox, trying alternative download..."
                    # Try without SSL verification as fallback
                    curl -kLO "https://github.com/nestybox/sysbox/releases/download/${SYSBOX_VERSION}/sysbox-ce_0.6.4-0.linux_amd64.deb" || {
                      echo "Failed to download Sysbox"
                      return 1
                    }
                  fi
                  
                  # Stop Docker before installing Sysbox
                  echo "Stopping Docker for Sysbox installation..."
                  systemctl stop docker 2>/dev/null || true
                  
                  # Install dependencies
                  apt-get update
                  apt-get install -y jq fuse rsync
                  
                  # Install Sysbox
                  echo "Installing Sysbox package..."
                  dpkg -i sysbox-ce_0.6.4-0.linux_amd64.deb || {
                    echo "Installing Sysbox dependencies..."
                    apt-get install -f -y
                    dpkg -i sysbox-ce_0.6.4-0.linux_amd64.deb
                  }
                  
                  # Cleanup
                  rm -f sysbox-ce_0.6.4-0.linux_amd64.deb
                  
                elif command -v yum >/dev/null 2>&1; then
                  # RHEL/CentOS based - install from GitHub
                  SYSBOX_VERSION="v0.6.4"
                  echo "Downloading Sysbox ${SYSBOX_VERSION} for RPM..."
                  
                  cd /tmp
                  curl -fsSLO "https://github.com/nestybox/sysbox/releases/download/${SYSBOX_VERSION}/sysbox-ce-0.6.4-0.linux_amd64-rpm.tar.gz"
                  
                  tar -xzf sysbox-ce-0.6.4-0.linux_amd64-rpm.tar.gz
                  
                  # Stop Docker before installing Sysbox
                  systemctl stop docker 2>/dev/null || true
                  
                  # Install Sysbox
                  yum install -y ./sysbox-ce/*.rpm
                  
                  # Cleanup
                  rm -rf sysbox-ce-0.6.4-0.linux_amd64-rpm.tar.gz sysbox-ce/
                fi
                
                echo "Sysbox installation completed"
                return 0
              }
              {{- end }}
              
              # Function to setup XFS for Docker storage with quota support
              setup_xfs_storage() {
                echo "Setting up XFS filesystem for Docker storage..."
                
                # Check current filesystem of /var/lib/docker
                DOCKER_DIR="/var/lib/docker"
                
                # Check if already on XFS
                if [ -d "$DOCKER_DIR" ]; then
                  FS_TYPE=$(df -T "$DOCKER_DIR" | tail -1 | awk '{print $2}')
                  echo "Current filesystem for $DOCKER_DIR: $FS_TYPE"
                  
                  if [ "$FS_TYPE" = "xfs" ]; then
                    echo "✓ Already on XFS filesystem"
                    
                    # Check if quota is enabled
                    if xfs_quota -x -c 'state' "$DOCKER_DIR" 2>/dev/null | grep -q "Project quota state on"; then
                      echo "✓ XFS quotas already enabled"
                      return 0
                    else
                      echo "⚠ XFS quotas not enabled, attempting to remount..."
                      # Try to remount with quota options
                      MOUNT_POINT=$(df "$DOCKER_DIR" | tail -1 | awk '{print $6}')
                      mount -o remount,prjquota "$MOUNT_POINT" 2>/dev/null || echo "Could not enable quotas on existing mount"
                    fi
                    return 0
                  fi
                  
                  echo "⚠ $DOCKER_DIR is on $FS_TYPE, not XFS"
                  echo "Will attempt to migrate to XFS loopback..."
                fi
                
                # Stop Docker before migration
                systemctl stop docker 2>/dev/null || true
                
                # Backup existing Docker data if it exists
                if [ -d "$DOCKER_DIR" ] && [ "$(ls -A $DOCKER_DIR)" ]; then
                  echo "Backing up existing Docker data..."
                  mv "$DOCKER_DIR" "${DOCKER_DIR}.backup.$(date +%s)"
                fi
                
                # Create XFS loopback file for Docker storage
                XFS_FILE="/var/lib/docker-xfs.img"
                XFS_SIZE="${XFS_STORAGE_SIZE:-50G}"  # Default 50GB, can be configured
                
                if [ ! -f "$XFS_FILE" ]; then
                  echo "Creating XFS storage file ($XFS_SIZE)..."
                  # Create sparse file
                  truncate -s "$XFS_SIZE" "$XFS_FILE"
                  
                  # Format as XFS with project quota support
                  echo "Formatting XFS filesystem with quota support..."
                  mkfs.xfs -f -n ftype=1 "$XFS_FILE"
                fi
                
                # Create mount point
                mkdir -p "$DOCKER_DIR"
                
                # Mount XFS with project quota enabled
                echo "Mounting XFS filesystem..."
                mount -o loop,prjquota "$XFS_FILE" "$DOCKER_DIR"
                
                # Add to fstab for persistence (if not already there)
                if ! grep -q "$XFS_FILE" /etc/fstab; then
                  echo "$XFS_FILE $DOCKER_DIR xfs loop,prjquota 0 0" >> /etc/fstab
                fi
                
                # Initialize XFS quota
                echo "Initializing XFS quota system..."
                xfs_quota -x -c 'project -s -d 1' "$DOCKER_DIR" 2>/dev/null || true
                
                echo "✓ XFS storage setup completed"
                return 0
              }
              
              # Function to configure Docker to use Sysbox runtime
              configure_docker_sysbox() {
                echo "Configuring Docker to use Sysbox runtime..."
                
                mkdir -p /etc/docker
                
                # Create or update Docker daemon configuration
                if [ -f /etc/docker/daemon.json ]; then
                  # Backup existing config
                  cp /etc/docker/daemon.json /etc/docker/daemon.json.bak
                fi
                
                # Write Docker daemon config with Sysbox runtime
                # Note: Not including storage-driver to avoid conflicts with GKE systemd flags
                cat > /etc/docker/daemon.json << 'DOCKERCONFIG'
              {
                "runtimes": {
                  "sysbox-runc": {
                    "path": "/usr/bin/sysbox-runc"
                  }
                },
                "default-runtime": "sysbox-runc",
                "log-driver": "json-file",
                "log-opts": {
                  "max-size": "10m",
                  "max-file": "3"
                }
              }
              DOCKERCONFIG
                
                echo "Docker configuration updated"
                return 0
              }
              
              # Setup XFS filesystem for Docker storage with quotas
              setup_xfs_storage
              
              {{- if .Values.services.runner.dockerInstaller.airgapped.enabled }}
              # Install dependencies first (required for sysbox and docker) - airgapped mode
              install_dependencies
              {{- end }}
              
              # Install Sysbox (before Docker, as Docker config depends on sysbox)
              install_sysbox
              
              # Install Docker
              install_docker
              
              # Configure Docker to use Sysbox
              configure_docker_sysbox
              
              # Start Sysbox services
              echo "Starting Sysbox services..."
              systemctl enable sysbox 2>/dev/null || true
              systemctl start sysbox 2>/dev/null || true
              
              # Start Docker
              echo "Starting Docker with Sysbox runtime..."
              systemctl restart docker
              
              # Verify installation
              echo "=== Verification ==="
              echo "Docker version:"
              docker version
              echo ""
              echo "Docker runtime:"
              docker info | grep -i runtime || echo "Runtime info not available"
              echo ""
              echo "Sysbox status:"
              systemctl status sysbox --no-pager -l || echo "Sysbox service status not available"
              
              EOF
              
              echo "Docker and Sysbox installer initialized. Monitoring services..."
              
              # Monitor and ensure Docker and Sysbox stay running
              while true; do
                nsenter -t 1 -m -u -n -i sh -c '
                  # Check Sysbox
                  if ! systemctl is-active --quiet sysbox 2>/dev/null; then
                    echo "Sysbox service is down, restarting..."
                    systemctl start sysbox 2>/dev/null || echo "Failed to start Sysbox"
                  fi
                  
                  # Check Docker
                  if ! systemctl is-active --quiet docker; then
                    echo "Docker service is down, restarting..."
                    systemctl start docker
                  fi
                ' || echo "Health check failed, will retry..."
                sleep 60
              done
              ln -s /host/var/lib/docker /var/lib/docker
        {{- end }}
        - name: runner
          image: "{{ include "daytona.imageRegistry" (dict "Values" .Values "serviceRegistry" .Values.services.runner.image.registry) }}/{{ .Values.services.runner.image.repository }}:{{ .Values.services.runner.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.services.runner.image.pullPolicy }}
          securityContext:
            privileged: true
          ports:
            - name: api
              containerPort: 3000
              hostPort: 3000
              protocol: TCP
            - name: ssh-gateway
              containerPort: 2220
              hostPort: 2220
              protocol: TCP
          env:
            # Configuration
            - name: API_PORT
              value: {{ .Values.services.runner.env.API_PORT | default "3000" | quote }}
            - name: ENVIRONMENT
              value: {{ .Values.services.runner.env.ENVIRONMENT | default "production" | quote }}
            - name: CONTAINER_RUNTIME
              value: {{ .Values.services.runner.env.CONTAINER_RUNTIME | default "" | quote }}
            - name: LOG_FILE_PATH
              value: {{ .Values.services.runner.env.LOG_FILE_PATH | default "/home/daytona/runner/runner.log" | quote }}
            - name: LOG_LEVEL
              value: {{ .Values.services.runner.env.LOG_LEVEL | default "info" | quote }}
            - name: SSH_GATEWAY_ENABLE
              value: {{ .Values.services.runner.env.SSH_GATEWAY_ENABLE | default "true" | quote }}
            - name: SSH_GATEWAY_PORT
              value: {{ .Values.services.runner.env.SSH_GATEWAY_PORT | default "2220" | quote }}
            - name: RESOURCE_LIMITS_DISABLED
              value: {{ .Values.services.runner.env.RESOURCE_LIMITS_DISABLED | default "false" | quote }}
            - name: CACHE_RETENTION_DAYS
              value: {{ .Values.services.runner.env.CACHE_RETENTION_DAYS | default "7" | quote }}
            - name: DAEMON_START_TIMEOUT_SEC
              value: {{ .Values.services.runner.env.DAEMON_START_TIMEOUT_SEC | default "30" | quote }}
            - name: SANDBOX_START_TIMEOUT_SEC
              value: {{ .Values.services.runner.env.SANDBOX_START_TIMEOUT_SEC | default "60" | quote }}
            # Secrets
            - name: SERVER_URL
              value: {{ .Values.services.runner.env.SERVER_URL | default "" | quote }}
            - name: API_TOKEN
              value: {{ .Values.services.runner.env.API_TOKEN | default "" | quote }}
            - name: SYSTEM_API_TOKEN
              value: {{ .Values.services.runner.env.SYSTEM_API_TOKEN | default "" | quote }}
            - name: AWS_REGION
              value: {{ .Values.services.runner.env.AWS_REGION | default "" | quote }}
            - name: AWS_ENDPOINT_URL
              value: {{ .Values.services.runner.env.AWS_ENDPOINT_URL | default "" | quote }}
            - name: AWS_ACCESS_KEY_ID
              value: {{ .Values.services.runner.env.AWS_ACCESS_KEY_ID | default "" | quote }}
            - name: AWS_SECRET_ACCESS_KEY
              value: {{ .Values.services.runner.env.AWS_SECRET_ACCESS_KEY | default "" | quote }}
            - name: AWS_DEFAULT_BUCKET
              value: {{ .Values.services.runner.env.AWS_DEFAULT_BUCKET | default "" | quote }}
            - name: SSH_PUBLIC_KEY
              value: {{ .Values.services.runner.env.SSH_PUBLIC_KEY | default "" | quote }}
            # Pod metadata
            - name: NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: DAEMON_BINARIES_DIR
              value: "/var/lib/daytona/binaries"
            - name: CONFIG_FILE_PATH
              value: {{ .Values.services.runner.env.CONFIG_FILE_PATH | default "/host-token/token.txt" | quote }}
            {{- if .Values.services.runner.extraEnv }}
            {{- include "daytona.tplvalues.render" (dict "value" .Values.services.runner.extraEnv "context" $) | nindent 12 }}
            {{- end }}
          volumeMounts:
            {{- if eq (.Values.services.runner.env.CONTAINER_RUNTIME | default "docker") "docker" }}
            - name: docker-socket
              mountPath: /var/run/
            {{- else }}
            - name: containerd-socket
              mountPath: /run/containerd/containerd.sock
            {{- end }}
            - name: host-root
              mountPath: /host
              readOnly: true
            - name: host-var-lib-docker
              mountPath: /var/lib/docker
              readOnly: true
            - name: logs
              mountPath: /home/daytona/runner
            - name: ssh-keys
              mountPath: /root/.ssh
            - name: daemon-binaries
              mountPath: /var/lib/daytona/binaries
            - name: host-token
              mountPath: /host-token
              readOnly: false
          resources:
            {{- toYaml .Values.services.runner.resources | nindent 12 }}
          livenessProbe:
            httpGet:
              path: /
              port: api
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /
              port: api
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
      volumes:
        - name: docker-socket
          hostPath:
            path: /var/run/
            type: Directory
        - name: containerd-socket
          hostPath:
            path: /run/containerd/containerd.sock
            type: Socket
        - name: host-root
          hostPath:
            path: /
            type: Directory
        - name: host-var-lib-docker
          hostPath:
            path: /var/lib/docker
            type: DirectoryOrCreate
        - name: logs
          hostPath:
            path: /var/log/daytona-runner
            type: DirectoryOrCreate
        - name: ssh-keys
          hostPath:
            path: /etc/daytona/ssh
            type: DirectoryOrCreate
        - name: daemon-binaries
          hostPath:
            path: /var/lib/daytona/binaries
            type: DirectoryOrCreate
        - name: host-token
          hostPath:
            path: /mnt/
            type: Directory
      {{- with .Values.services.runner.affinity | default .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
{{- end }}